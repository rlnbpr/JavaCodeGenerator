<@SCRIPT
var gIndent = "    ";
var candidateClass = getArgument("TargetClass");
var startLine = getArgument("CodeStartMarkLine");
var endLine = getArgument("CodeEndMarkLine");
var target = getArgument("target");

CodeFactory = {};

CodeFactory.getSourceCode = function(source) {
    var sourceCode = "";
    var type = "";
    switch(source.GetClassName()){
        case "UMLClass":
            type = "class";
            break;
        case "UMLInterface":
            type = "interface"
            break;
        case "UMLEnumeration":
        case "UMLException":
        case "UMLSignal":

        default:
    }

    if (type != "") {
        sourceCode = CodeFactory.getOOSourceCode(source, type);
    }
    
    return sourceCode;
}

CodeFactory.getFileName = function(source) {
    var path = getTarget() + "\\";
    var names = source.Pathname.split("::");
    for (i=2; i<names.length; i++) {
        if (names[i] == source.Name) {
            return path + "\\" + source.Name + ".java";
        }

        path = path + "\\" + names[i];
        if (packageInfo != "") {
            packageInfo += ".";
        }
        packageInfo += names[i];
        if (!folderExists(path)) {
            createFolder(path);
        }
    }
}

CodeFactory.getOOSourceCode = function(source, type) {
    var geners = CodeFactory.getGeneralization(source);
    var impIfs = CodeFactory.getImplInterface(source);
    var attrs = CodeFactory.getAttrsCode(source, gIndent);
    var methods = CodeFactory.getMethodsCode(source, gIndent);

    if (type == "interface") {
        return "public interface " + source.Name +  " " + geners + "{\n"
            + attrs + methods + "}";
    }
    return "public class " + source.Name + " " + geners + impIfs + "{\n" 
        + attrs + methods + "}";
}

CodeFactory.getGeneralization = function(source) {
    var sourceCode = "";
    var n = source.GetGeneralizationCount();

    for (i = 0;  i < n; i++) {
        gener = source.GetGeneralizationAt(i);

        if (source.Name == gener.Child.Name) {
            return "extends " + gener.Parent.Name + " ";
        }
    }
    return sourceCode;
}

CodeFactory.getImplInterface = function(source) {
    var sourceCode = "";
    var n = source.GetClientDependencyCount();
    
    for (i = 0;  i < n; i++) {
        depen = source.GetClientDependencyAt(i);
        if (depen.GetClassName() != "UMLRealization") {
            continue;
        }

        if (sourceCode != "") {
            sourceCode += ", ";
        }
        sourceCode += depen.Supplier.Name;
    }
    return "implements " + sourceCode + " ";
}

CodeFactory.getAttrsCode = function(source, indent) {
    var sourceCode = "";
    var n = source.GetAttributeCount();
    println("number of attr is " + n);
    var i;
    for (i = 0;  i < n; i++) {
        var attr = source.GetAttributeAt(i);

        visibility = CodeFactory.getVisibility(attr);
        sourceCode += indent + visibility + attr.TypeExpression + " " + attr.Name + ";\n";
        println(sourceCode);
    }
   
    if (sourceCode.localeCompare("") != 0) {
        return sourceCode + "\n\n";
    } 
    return sourceCode;
}

CodeFactory.getMethodsCode = function(source, indent) {
    var sourceCode = "";
    var n = source.GetOperationCount();
    println("Operation num is " + n)
    var i = 0;
    for (i=0; i < n; i++) {
        println("current round is " + i)
        operation = source.GetOperationAt(i);

        visibility = CodeFactory.getVisibility(operation);
        scope      = CodeFactory.getScope(operation);
        parameters = CodeFactory.getParameters(operation);

        var type = "";
        if (operation.StereotypeName != "create") {
            type   = CodeFactory.getReturnType(operation);
        }

        body       = CodeFactory.getMethodImpl(operation, gIndent);

        sourceCode +=  indent + visibility + scope + type + operation.Name 
            + "("  + parameters + ") {\n";
        sourceCode +=  body + indent + "}\n\n";
    }
    return sourceCode;
}

CodeFactory.getVisibility = function(source) {
    var visibilityStr = "";
    var visibility;

    try {
        visibility = source.MOF_GetAttribute("Visibility");
    }catch(error){
        visibility = null;
    }
    
    switch(visibility){
            
        case "vkPackage":
            visibilityStr    = "internal";
            break;
            
        case "vkPrivate":
            visibilityStr    = "private";
            break;
            
        case "vkProtected":
            visibilityStr    = "protected";
            break;
            
        case "vkPublic":
        default:
            visibilityStr    = "public";
            break;
    }
    
    return visibilityStr + " ";
}

CodeFactory.getScope = function(source) {
    try {
        if (source.MOF_GetAttribute("OwnerScope") == "skClassifier") {
            return "static ";
        }
    }catch(error){
    }
    return "";
}

CodeFactory.getParameters = function(source) {
    println("Enter CodeFactory.getParameters")
    var paraSrcCode = "";

    try {
        var n = source.GetParameterCount();
        var i = 0;
        for (i=0; i<n; i++) {
            parameter = source.GetParameterAt(i);
            if (parameter.MOF_GetAttribute("DirectionKind") != "pdkReturn") {
                paraSrcCode += parameter.TypeExpression + " " + parameter.Name;
            }
        }
    } catch(error) {
    }
    println(paraSrcCode)
    return paraSrcCode;
}

CodeFactory.getReturnType = function(source) {
    try {
        var n = source.GetParameterCount();
        var i = 0;
        for (i=0; i<n; i++) {
            parameter = source.GetParameterAt(i);
            if (parameter.MOF_GetAttribute("DirectionKind") == "pdkReturn") {
                return parameter.TypeExpression + " ";
            }
        }
    } catch(error) {
    }

    return "void ";
}

CodeFactory.getMethodImpl = function(source, indent) {
    if (!source.Documentation) return "";

    var src = null;
    var doc = source.Documentation.replace(/\r\n/g, "\n");
    doc = doc.replace(/\r/g, "\n");

    var lines = doc.split("\n");
    var i = 0;
    for(i=0; i<lines.length; i++) {
        if (src == null) {
            if (lines[i].indexOf(startLine) != -1) {
                src = "";
            }
        } else {
            if (lines[i].indexOf(endLine) != -1) {
                return src;
            }
            src += indent + lines[i] + "\n";
        }
    }
    return "";
}

@>

<@REPEAT {R}::;UMLClassifier;;@>
<@SCRIPT
    if (candidateClass == "" || candidateClass.indexOf(current().Name) != -1) {
        sourceCode = CodeFactory.getSourceCode(current());
    } else {
        sourceCode = null;
    }
    
    if (sourceCode){
        var packageInfo = "";
        var fileName = CodeFactory.getFileName(current()); 

        fileBegin(fileName);

        if (packageInfo != "") {
            println("package " + packageInfo + ";\n")
        }
        print(sourceCode);

        fileEnd();
    }
@>
<@ENDREPEAT@>

